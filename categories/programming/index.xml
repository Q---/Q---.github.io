<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>programming on Adventures in Typescript</title>
    <link>https://code.lol/categories/programming/</link>
    <description>Recent content in programming on Adventures in Typescript</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Thu, 08 Dec 2022 22:58:35 -0800</lastBuildDate><atom:link href="https://code.lol/categories/programming/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Type-level Collatz Sequence</title>
      <link>https://code.lol/post/programming/type-level-collatz/</link>
      <pubDate>Thu, 08 Dec 2022 22:58:35 -0800</pubDate>
      
      <guid>https://code.lol/post/programming/type-level-collatz/</guid>
      <description>The Collatz conjecture is an unsolved problem in mathematics. It states that for any positive integer n, the sequence of numbers generated by the following algorithm will eventually reach 1. These are also called the hailstone numbers.
function collatz(n: number): number {  return n % 2 === 0 ? n / 2 : 3 * n + 1; } The sequence generated by a given $n$ is the sequence of numbers n, collatz(n), collatz(collatz(n)), collatz(collatz(collatz(n))), and so on.</description>
    </item>
    
    <item>
      <title>Typesafe Function Composition</title>
      <link>https://code.lol/post/programming/typesafe-function-composition/</link>
      <pubDate>Sun, 09 Oct 2022 16:45:40 -0700</pubDate>
      
      <guid>https://code.lol/post/programming/typesafe-function-composition/</guid>
      <description>Do ya wanna know how to type function composition in Typescript? Read on!
  1. Background  1.1. Type-theoretic Pseudocode   2. Typescript  2.1. IsComposablePair  2.1.1. Type-based Pattern Matching using infer 2.1.2. IsComposablePair   2.2. Every 2.3. Pair   3. Component Synthesis 4. Function Integration 5. Future Work: Constructive Approach  1. Background Function composition is an operation that takes two functions, $f$ and $g$, and produces a new function $h$ such that $h(x) = g(f(x))$.</description>
    </item>
    
    <item>
      <title>Towards a well-typed plugin architecture</title>
      <link>https://code.lol/post/programming/plugin-architecture/</link>
      <pubDate>Mon, 05 Sep 2022 12:03:54 -0700</pubDate>
      
      <guid>https://code.lol/post/programming/plugin-architecture/</guid>
      <description>declare abstract class EnginePlugin&amp;lt;I = unknown, D = unknown&amp;gt; {  createInterface?(Ã¸: Record&amp;lt;string, unknown&amp;gt;): I  getDependencies?(): D }  type Defined&amp;lt;T&amp;gt; = T extends undefined ? never : T  type ExtractPlugins&amp;lt;T&amp;gt; = T extends Engine&amp;lt;infer PX&amp;gt; ? PX : never  type UnionToIntersection&amp;lt;U&amp;gt; = (  U extends unknown ? (k: U) =&amp;gt; void : never ) extends (k: infer I) =&amp;gt; void  ? I  : never  type MergeInterfaces&amp;lt;  E extends Engine,  K extends keyof EnginePlugin, &amp;gt; = UnionToIntersection&amp;lt;ReturnType&amp;lt;Defined&amp;lt;ExtractPlugins&amp;lt;E&amp;gt;[number][K]&amp;gt;&amp;gt;&amp;gt;  type Assume&amp;lt;T, U&amp;gt; = T extends U ?</description>
    </item>
    
    <item>
      <title>A non-recursive type-level inclusion operator</title>
      <link>https://code.lol/post/programming/non-recursive-includes/</link>
      <pubDate>Sat, 27 Aug 2022 16:37:21 -0700</pubDate>
      
      <guid>https://code.lol/post/programming/non-recursive-includes/</guid>
      <description>type E1&amp;lt;X&amp;gt; = &amp;lt;T&amp;gt;() =&amp;gt; T extends X ? 0 : 1 type E2&amp;lt;X&amp;gt; = &amp;lt;T&amp;gt;() =&amp;gt; T extends X ? 0 : 1  type IsEqual&amp;lt;X, Y&amp;gt; = E1&amp;lt;X&amp;gt; extends E2&amp;lt;Y&amp;gt; ? true : false  /** * Whether or not T includes U as an element. */ type Includes&amp;lt;T extends readonly unknown[], U&amp;gt; = true extends {  [key in keyof T]: IsEqual&amp;lt;T[key], U&amp;gt; }[number] ? true : false A non-recursive type-level Includes operator in Typescript Introduction Includes is a type-level operator that determines whether a given type T includes a given type U as an element.</description>
    </item>
    
    <item>
      <title>Point-free Programming via HKTs</title>
      <link>https://code.lol/post/programming/hkt-tacit/</link>
      <pubDate>Fri, 11 Mar 2022 09:34:39 -0800</pubDate>
      
      <guid>https://code.lol/post/programming/hkt-tacit/</guid>
      <description>In Typescript, point-free programming has been traditionally limited due to the difficulty the type system has representing the abstracted types associated with point-free (also called &amp;rsquo;tacit&amp;rsquo;) programming.
 1. What is Tacit Programming? 2. Type-Level Programming  2.1. The Hard (Naive) Way 2.2. Tacit Logic via HKTs   3. Addendum: Library  3.1. Basic HKT Abstractions 3.2. HKT Composition 3.3. Narrow Type Inference 3.4. Value-level Apply 3.5. Auto-applyable HKTs 3.</description>
    </item>
    
    <item>
      <title>Variadic HKT Composition</title>
      <link>https://code.lol/post/programming/variadic-hkt-composition/</link>
      <pubDate>Sat, 05 Mar 2022 00:17:15 -0800</pubDate>
      
      <guid>https://code.lol/post/programming/variadic-hkt-composition/</guid>
      <description>In a previous article, Higher Kinded Types in Typescript, we explored how to encode HKTs, as well as some of their applications.
For example, we could define a value and type-level operation like the following:
// &amp;#34;hello! hello!&amp;#34; const result = map(double, map(append(&amp;#34;! &amp;#34;), &amp;#34;hello&amp;#34;)); On both the type and value levels, the given string goes through a complex operation. In the end though, the type system can still capture and encode the operations being performed.</description>
    </item>
    
    <item>
      <title>Higher Kinded Types in Typescript</title>
      <link>https://code.lol/post/programming/higher-kinded-types/</link>
      <pubDate>Thu, 03 Mar 2022 22:18:42 -0800</pubDate>
      
      <guid>https://code.lol/post/programming/higher-kinded-types/</guid>
      <description>HKTs are a powerful abstraction. Just as there are different types of higher-order functions, so are there so-called &amp;lsquo;higher-kinded types&amp;rsquo;.
Taxonomy This blog post concerns one particular type of HKT - to define the taxonomy, first we will cover a few types, and a way they can be categorized.
We can classify types in terms of &amp;lsquo;order&amp;rsquo;, a rough level of abstraction.
Here are a few zero-order types that exist:</description>
    </item>
    
    <item>
      <title>Programs of Length N: Collatz, Chaitin, and Church</title>
      <link>https://code.lol/post/programming/programs-of-length-n/</link>
      <pubDate>Fri, 03 Sep 2021 15:12:34 -0700</pubDate>
      
      <guid>https://code.lol/post/programming/programs-of-length-n/</guid>
      <description>There are a few interesting questions about the nature of programs, and specifically about sets of programs, as represented by lambda calculus expressions.
 1. How many programs have N terms? 2. How fast does the set of programs of length N grow? 3. How many programs of length N converge? 4. What is the longest-running convergent program of length N? 5. How fast does BB(N) grow? 6. What percentage of programs converge?</description>
    </item>
    
  </channel>
</rss>
