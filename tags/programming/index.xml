<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>programming on Adventures in Typescript</title>
    <link>https://code.lol/tags/programming/</link>
    <description>Recent content in programming on Adventures in Typescript</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Tue, 07 Feb 2023 23:17:12 -0800</lastBuildDate><atom:link href="https://code.lol/tags/programming/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Kind Reification</title>
      <link>https://code.lol/post/programming/kind-reification/</link>
      <pubDate>Tue, 07 Feb 2023 23:17:12 -0800</pubDate>
      
      <guid>https://code.lol/post/programming/kind-reification/</guid>
      <description>The hkt-toolbelt now provides a way to &amp;lsquo;reify&amp;rsquo; a higher-order type into a concrete function type. This is useful for representation of point-free code.
to reify: make (something abstract) more concrete or real.
Basics of Higher-Order Types For the purposes of hkt-toolbelt, a higher-order type is merely a representation of a type mapping, i.e. an &amp;lsquo;applicable&amp;rsquo; type that maps from an input type to an output type.
Higher-order types are useful because they can take in higher order types, or return higher order types.</description>
    </item>
    
    <item>
      <title>Point-free Programming via HKTs</title>
      <link>https://code.lol/post/programming/hkt-tacit/</link>
      <pubDate>Fri, 11 Mar 2022 09:34:39 -0800</pubDate>
      
      <guid>https://code.lol/post/programming/hkt-tacit/</guid>
      <description>In Typescript, point-free programming has been traditionally limited due to the difficulty the type system has representing the abstracted types associated with point-free (also called &amp;rsquo;tacit&amp;rsquo;) programming.
1. What is Tacit Programming? 2. Type-Level Programming 2.1. The Hard (Naive) Way 2.2. Tacit Logic via HKTs 3. Addendum: Library 3.1. Basic HKT Abstractions 3.2. HKT Composition 3.3. Narrow Type Inference 3.4. Value-level Apply 3.5. Auto-applyable HKTs 3.6. HKT-Level Flow 3.7. HKT-level Split 3.</description>
    </item>
    
    <item>
      <title>Variadic HKT Composition</title>
      <link>https://code.lol/post/programming/variadic-hkt-composition/</link>
      <pubDate>Sat, 05 Mar 2022 00:17:15 -0800</pubDate>
      
      <guid>https://code.lol/post/programming/variadic-hkt-composition/</guid>
      <description>In a previous article, Higher Kinded Types in Typescript, we explored how to encode HKTs, as well as some of their applications.
For example, we could define a value and type-level operation like the following:
// &amp;#34;hello! hello!&amp;#34; const result = map(double, map(append(&amp;#34;! &amp;#34;), &amp;#34;hello&amp;#34;)); On both the type and value levels, the given string goes through a complex operation. In the end though, the type system can still capture and encode the operations being performed.</description>
    </item>
    
    <item>
      <title>Higher Kinded Types in Typescript</title>
      <link>https://code.lol/post/programming/higher-kinded-types/</link>
      <pubDate>Thu, 03 Mar 2022 22:18:42 -0800</pubDate>
      
      <guid>https://code.lol/post/programming/higher-kinded-types/</guid>
      <description>HKTs are a powerful abstraction. Just as there are different types of higher-order functions, so are there so-called &amp;lsquo;higher-kinded types&amp;rsquo;.
Taxonomy This blog post concerns one particular type of HKT - to define the taxonomy, first we will cover a few types, and a way they can be categorized.
We can classify types in terms of &amp;lsquo;order&amp;rsquo;, a rough level of abstraction.
Here are a few zero-order types that exist:</description>
    </item>
    
    <item>
      <title>Type Guard Composition</title>
      <link>https://code.lol/post/programming/type-guard-composition/</link>
      <pubDate>Sun, 14 Nov 2021 12:08:01 -0800</pubDate>
      
      <guid>https://code.lol/post/programming/type-guard-composition/</guid>
      <description>Type guards are a powerful tool for type system design. They are used to express that a type is only valid if it satisfies a certain condition. For example, we can express that a type is only valid if it is a number or a string.
1. Union Type Guards 1.1. Naive Union Implementation 1.2. 2-adic Union Composition 1.3. N-adic Union Composition 1.3.1. GuardReturnType 1.3.2. Variadic Is-Union 1.3.3. References for this Section 2.</description>
    </item>
    
    <item>
      <title>Programs of Length N: Collatz, Chaitin, and Church</title>
      <link>https://code.lol/post/programming/programs-of-length-n/</link>
      <pubDate>Fri, 03 Sep 2021 15:12:34 -0700</pubDate>
      
      <guid>https://code.lol/post/programming/programs-of-length-n/</guid>
      <description>There are a few interesting questions about the nature of programs, and specifically about sets of programs, as represented by lambda calculus expressions.
1. How many programs have N terms? 2. How fast does the set of programs of length N grow? 3. How many programs of length N converge? 4. What is the longest-running convergent program of length N? 5. How fast does BB(N) grow? 6. What percentage of programs converge?</description>
    </item>
    
    <item>
      <title>Unchained Tuple Types</title>
      <link>https://code.lol/post/programming/unchained-tuple-types/</link>
      <pubDate>Sat, 09 Jan 2021 16:33:40 -0800</pubDate>
      
      <guid>https://code.lol/post/programming/unchained-tuple-types/</guid>
      <description>The asserts syntax introduced with TS 3.7 allows us to interleave mutative runtime code with type annotations to express type mutations in a powerful way.
This allows us to do away with the chaining syntax as described in my earlier article, Chained Tuple Types, and express our Set mutations in a much more familiar iterative way:
const set: Set = new Set(); set.insert(2); set.insert(4); set.insert(8); set.remove(4); const hasResult1 = set.has(8); // :: true const hasResult2 = set.</description>
    </item>
    
    <item>
      <title>String Deduplication on the Type Level</title>
      <link>https://code.lol/post/programming/type-level-dedupe/</link>
      <pubDate>Sat, 09 Jan 2021 15:18:24 -0800</pubDate>
      
      <guid>https://code.lol/post/programming/type-level-dedupe/</guid>
      <description>The string deduplication problem is a canonical one within computer science, serving a similar purpose as fizz-buzz in terms of being an example of a simple problem that a reasonably knowledgable practitioner should be able to solve with minimal effort.
The problem appears in a few variants, but briefly one such variant is to remove duplicate letters in a given string, such that the string then has only one instance of any given letter.</description>
    </item>
    
    <item>
      <title>Chained Tuple Types</title>
      <link>https://code.lol/post/programming/chained-tuple-types/</link>
      <pubDate>Tue, 05 Jan 2021 20:23:23 -0800</pubDate>
      
      <guid>https://code.lol/post/programming/chained-tuple-types/</guid>
      <description>With Typescript 4.1, it&amp;rsquo;s now possible to use variadic tuple types to construct large types with what appears to be runtime code. The general idea is that we will utilize a chaining pattern, where each operation on the chain returns an expanded version of the chain&amp;rsquo;s type.
To motivate the example, let us consider a Set class. Our Set is a chaining class, where you may insert, remove, and check for the existence of numbers.</description>
    </item>
    
    <item>
      <title>Enforcing Function Map Constraints</title>
      <link>https://code.lol/post/programming/enforcing-function-map-constraints/</link>
      <pubDate>Wed, 16 Dec 2020 19:41:08 -0800</pubDate>
      
      <guid>https://code.lol/post/programming/enforcing-function-map-constraints/</guid>
      <description>Some &amp;ldquo;easy to state&amp;rdquo; problems in Typescript can require somewhat sophisticated type constructs.
Let&amp;rsquo;s say you want to enforce that every function in a particular map takes in as its first parameter, either a number or a string:
type PermissibleInput = number | string; const myFunctionMap = { foobar(x: number): void; barfoo(y: string): void; } If you do this in the naive way, as e.g. Record&amp;lt;string, (number | string) =&amp;gt; any&amp;gt;, you will discover that this type actually encodes the requirements that every function must support both input types - which is a problem, as myFunctionMap is not actually composed of such functions.</description>
    </item>
    
    <item>
      <title>Self Modifying Type Predicates in Typescript</title>
      <link>https://code.lol/post/programming/self-modifying-type-predicates/</link>
      <pubDate>Sun, 03 May 2020 19:41:57 -0700</pubDate>
      
      <guid>https://code.lol/post/programming/self-modifying-type-predicates/</guid>
      <description>Typescript&amp;rsquo;s type system is uniquely powerful among mainstream programming languages, approximating the expressive power of Haskell or Idris, while also remaining flexible enough for production applications.
Type predicates are a useful tool in building a well-typed software framework. Essentially, they allow you to &amp;ldquo;simulate&amp;rdquo; dependent types, a powerful type feature present in Idris.
Further explanation on type predicates can be found here.
The premise of this article is a usage of type predicates I haven&amp;rsquo;t seen discussed online - most type predicates just modify one of their arguments, but you can actually form a predicate on this because it is an implicit argument.</description>
    </item>
    
  </channel>
</rss>
